// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  STUDENT
  TUTOR
  ADMIN
}

model User {
  id            String  @id @default(uuid())
  email         String  @unique
  name          String?
  programme     String?
  matricNo      String? @unique
  matricCardUrl String?
  passwordHash  String

  role            UserRole             @default(STUDENT)
  roleAssignments UserRoleAssignment[]

  isTutorApproved Boolean  @default(false)
  createdAt       DateTime @default(now())
  avatarUrl       String?

  tutorApplications TutorApplication[]
  studentSessions   Session[]          @relation("StudentSessions")
  tutorSessions     Session[]          @relation("TutorSessions")

  verificationStatus String  @default("PENDING_REVIEW")
  ocrText            String?
  ocrMatchedMatric   Boolean @default(false)
  ocrMatchedName     Boolean @default(false)

  isDeactivated           Boolean        @default(false)
  deactivatedAt           DateTime?
  deactivationReason      String?
  deactivationReasonOther String?
  tutorSubjects           TutorSubject[]

  notifications Notification[]
}

model UserRoleAssignment {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  role      UserRole
  createdAt DateTime @default(now())

  @@unique([userId, role]) // prevents duplicates
}

model TutorApplication {
  id              String    @id @default(cuid())
  user            User      @relation(fields: [userId], references: [id])
  userId          String
  subjects        String
  cgpa            Float?
  availability    String?
  status          String    @default("PENDING") // PENDING | APPROVED | REJECTED
  createdAt       DateTime  @default(now())
  reviewedAt      DateTime?
  rejectionReason String?
  transcriptPath  String?
}

enum SessionStatus {
  PENDING
  ACCEPTED
  COMPLETED
  CANCELLED
}

enum ProposalStatus {
  PENDING
  ACCEPTED
  REJECTED
}


model Subject {
  id        String   @id @default(cuid())
  code      String   @unique // e.g. WIA2003
  title     String // e.g. Data Structures
  aliases   String? // optional CSV: "DSA,Data Structure"
  createdAt DateTime @default(now())

  tutorLinks TutorSubject[]
  sessions   Session[]
}

model TutorSubject {
  id        String   @id @default(cuid())
  tutor     User     @relation(fields: [tutorId], references: [id])
  tutorId   String
  subject   Subject  @relation(fields: [subjectId], references: [id])
  subjectId String
  createdAt DateTime @default(now())

  @@unique([tutorId, subjectId])
}

model Session {
  id String @id @default(cuid())

  student   User   @relation("StudentSessions", fields: [studentId], references: [id])
  studentId String

  tutor   User?   @relation("TutorSessions", fields: [tutorId], references: [id])
  tutorId String?

  subject   Subject @relation(fields: [subjectId], references: [id])
  subjectId String

  scheduledAt DateTime
  durationMin Int      @default(60)
  endsAt DateTime?

  status SessionStatus @default(PENDING)

  notes         String?
  cancelledAt   DateTime?
  cancelReason  String?
  rescheduledAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([studentId, status])
  @@index([tutorId, status])
  @@index([scheduledAt])

    // ---- reschedule proposal flow (tutor -> student confirm) ----
  proposedAt       DateTime?
  proposedEndAt    DateTime?
  proposedNote     String?
  proposalStatus   ProposalStatus?
  proposedByUserId String?

  studentReminderEmailId String?
  tutorReminderEmailId   String?

  calendarUid      String?  @unique
  calendarSequence Int      @default(0)
}

enum NotificationStatus {
  QUEUED
  SENT
  DELIVERED
  READ
  FAILED
}

model Notification {
  id        String             @id @default(cuid())
  userId    String
  type      String
  title     String
  body      String
  data      Json?
  status    NotificationStatus @default(QUEUED)

  createdAt DateTime           @default(now())
  sentAt    DateTime?
  readAt    DateTime?

  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  dedupeKey String?            @db.VarChar(120)

  @@unique([userId, dedupeKey])
  @@index([userId, createdAt])
  @@index([status, createdAt])
  @@index([userId, status])
}

